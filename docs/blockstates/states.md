Block States
============

Please read ALL of this guide before starting to code. Your understanding will be more comprehensive and correct than if you just picked parts out.

In Minecraft 1.8, direct manipulation of blocks and metadata values have been abstracted away into what is known as blockstates.
The premise of the system is to remove the manipulation of raw metadata, which are ugly and carry no meaning.

For example, consider this

```Java
switch(meta) {
  case 0: // it's south and on the lower half of the block
  case 1: // it's south on the upper side of the block
  case 2: // it's north and on the lower half of the block
  case 3: // it's north and on the upper half of the block
  ... etc.
}
```

The numbers themselves carry no meaning whatsoever! If the comments weren't there we would have no idea what the meaning of each number is.

A New Way of Thinking
---------------------

Instead of having to munge around with numbers everywhere, we instead declare the *properties* that the block should have. Unsurprisingly, the interface is called `IProperty`.
Note that the meta numbers aren't gone, the new system just allows us to stuff all the dirty number crunching into two methods and forget about them.

In your Block class, override the method `createBlockState()`. This will be called when your block is first initialized, and returns a `BlockState` object. This name is kind of a misnomer. It isn't a block state, it rather manages all the blockstates of your block. Its name in 1.9 has been changed to the more appropriate `BlockStateContainer`. Call the constructor of this class, and pass it your block object, and then all `IProperty`'s that the block will need. `IProperty` instances should be static final fields. Vanilla stores them with their associated block classes, while other mods may share a single `IProperty` among its blocks.

Vanilla provides us a couple implementations of IProperty<?>: 
    * PropertyInteger: Implements `IProperty<Integer>`. Created by calling PropertyInteger.create("<name>", <min>, <max>);
    * PropertyBool: Implements `IProperty<Boolean>`. Created by calling PropertyBool.create("<name>");
    * PropertyEnum<E extends Enum<E>>: Implements `IProperty<E>`, Defines a property that can take on the values of an Enum class. Created by calling PropertyEnum.create("name", <enumclass>);
        * You can also specify specific enum values that are valid by passing them in using varargs or a Collection. There is also a factory that takes a predicate that returns true if the value is valid
    * PropertyDirection: This is a convenience implementation of PropertyEnum<EnumFacing>
        * Several convenience predicates are also provided. For example, to get a property that represents the cardinal directions, you would call `PropertyDirection.create("<name>", EnumFacing.Plane.HORIZONTAL)`. Or to get the X directions, `PropertyDirection.create("<name>", EnumFacing.Axis.X)`

Finally, Minecraft will then generate all possible IBlockState objects for your block by generating all possible combinations of the property values.

!!! Note 
    If your mod has an API or is meant to be interacted with from other mods, it is HIGHLY, HIGHLY recommended that you store your `IProperty`'s in your API. That way, people can use blockstates to change your blocks without having to fudge around with metadata.

IBlockState
-----------

`IBlockState` is the new "block + meta" of 1.8. Within it, it carries information about a Block, its properties, and a *value* for each of those properties. For example, an `IBlockState` of a wooden log contains the Block "Blocks.log" or "Blocks.log2", the *properties* AXIS and VARIANT, and *values* for those properties, e.g. `Axis.Y` and `BlockPlanks.WoodType.BIRCH`.
You can acquire one with `world.getBlockState(BlockPos)`
To test the value of a property, use IBlockState.getValue(<property>). So for our log, if we wanted to see if it was birch we would do `world.getBlockState(pos).getValue(VARIANT) == BlockPlanks.WoodType.BIRCH`.
To get the IBlockState object for another combination of properties and valuee, use `withProperty(IProperty<T>, T)`. This will return a different IBlockState object with the values you requested.

!!! Note
    All IBlockState objects are generated by Minecraft on startup. For each unique set of block+properties+values, there is exactly one IBlockState. Thus it is perfectly safe and recommended to compare IBlockStates using reference equality (==) ! 

In the constructor of your block, it is necessary you set the default blockstate. You simply do this by calling `setDefaultState(blockState.getBaseState().withProperty(...))`. Be sure to do this for ALL of your `IProperty`'s, or the values of the ones you skip will be undefined in your default blockstate, which once again causes hidden bugs that don't crash the game but have strange behaviour.

Saving and Restoring from Meta
------------------------------

If your Block uses no `IProperty`'s, you don't need to override these two methods. Otherwise, you MUST or else Minecraft will crash on startup.
Override getMetaFromState and getStateFromMeta. These two methods are where all the ugly bitmasking/bitpacking/bit testing will take place. Note that since the save format has not changed, you are still limited to 16 meta values (0 to 15 inclusive).

!!! Warning
    Your getMetaFromState and getStateFromMeta methods MUST be one to one! In other words, the same set of properties and values must map to the same meta value and back. Failing to do this, unfortunately, WON'T cause a crash. It'll just cause everything to behave extremely weirdly.

IBlockState: More than just Block and Meta
------------------------------------------

This isn't the end of the story, though. 
If you've ever hovered over a vanilla fence with F3 activated, you might have noticed the boolean properties north, south, west, and east with. Sharper minds might notice that fences don't save their connection to meta, so what's going on here?
It turns out, `IBlockState`s are able to hold values for properties that aren't saved to meta! You register them in createBlockState as usual.
Override `getActualState` in your block class. Here, fences and redstones check their sides for connections, and modify the state appropriately. 

!!! Note
    Querying `world.getBlockState()` will give you the `IBlockState` representing the saved metadata. Thus the returned `IBlockState` will not have all the data from `getActualState` filled in. If that matters to your code, make sure you call `getActualState`!

!!! Warning
    Do NOT touch your rendering-only properties in getMetaFromState/getStateFromMeta! Those two methods should only manipulate the properties that you need to save.

Further Reading
---------------

Rendering in 1.8 and Extended States: TODO
